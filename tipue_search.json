{
    "pages": [
        {
            "title": "Django - Aula 02 - Criando o projeto", 
            "text":"Pré-requisitos Agora que conhecemos um pouquinho sobre a framework é hora de botar a mão na massa! Antes porém, é necessário preencher alguns requisitos do sistema: Controle de versão: Vamos usar o GIT para essa finalidade, então certifique-se de que ele esteja instalado na sua máquina. Não conhece ou não sabe o que é GIT ainda? Urgente, atualize-se porque saber trabalhar com GIT é uma exigência na nossa área! Um bom tutorial pode ser achado aqui. Ambientes virtuais: Se não sabe o que são, sua importância, ou como instalar, escrevi sobre esse assunto em um outro artigo. Criação do ambiente O primeiro passo é nos certificarmos de termos todo o ambiente virtual preparado para a instalação dos pacotes do projeto. Vamos criar um ambiente chamado “django_project” utilizando o Python 3 como padrão (aliás sempre que possível devemos fazer dessa forma pois a cada dia menos projetos são baseados no Python 2). $ cd pasta_do_projeto $ virtualenv -p usr/bin/python3 django_project Ativamos o nosso ambiente: $ source django_project/bin/activate Devemos ter agora o ambiente ativado e pronto para uso. O prompt do terminal por padrão mostra qual o ambiente que está sendo utilizado da seguinte maneira (no nosso caso): (django_project) $ Instalação de dependências Vamos instalar agora a última versão do Django framework com o PIP: (django_project) $ pip install django", 
            "tags": "Django", 
            "loc": "https://rschalch.github.io/django-framework-aula-02-criando-projeto.html"
        },
        {
            "title": "Django - Aula 01 - Introdução", 
            "text":"Introdução à framework Django é a principal e mais conhecida framework Python para web nos dias atuais. Sua filosofia é baseada em RAD, um conceito muito importante no mundo do desenvolvimento de software. Suas características são: Baixo acoplamento: As várias camadas da framework não devem conhecer sobre o funcionamento de outras, a menos que absolutamente necessário. Esse tipo de modelo permite alto grau de modularização e expansão já que cada parte é independente. Assim, futuras mudanças na aplicação serão mais seguras, já que o risco de uma parte interferir com a outra é mínimo. Menos código: Django utiliza todo o poder dinâmico da linguagem Python, assim alcançamos grandes resultados escrevendo pouquíssimo código. Rápido desenvolvimento: A framework permite que ultrapassemos muitas tarefas tediosas no ciclo da construção de uma aplicação, um exemplo disso é a geração automática de um sistema de administração baseado nos modelos de dados que criamos. Apenas com essa caractérística podemos construir um sistema CRUD em poucos minutos. Não repetição: Cada conceito ou parte de código deverá existir em um único lugar apenas, eliminando redundâncias. A idéia é reduzir ao máximo o trabalho de alterações dentro do software e fazê-lo mais conciso e inteligente. No decorrer desse curso introdutório vamos desenvolver uma simple aplicação CRUD para ajudar quem está começando a se familiarizar com os conceitos fundamentais do Django!", 
            "tags": "Django", 
            "loc": "https://rschalch.github.io/django-framework-aula-01-introducao.html"
        },
        {
            "title": "Requests", 
            "text":"Uma simples e elegante biblioteca para requisições HTTP Nos dias de hoje, podemos imaginar algum software que não faça algum tipo de consulta na internet? Conforme a integração tecnológica aumenta, surge também a necessidade de uma centralização cada vez maior a fim de otimizar todo um ecossistema de aplicações, evitar duplicações, aproveitar recursos, etc. Por consequência, o trabalho de pesquisar e extrair dados da rede, não apenas tornou-se uma ciência por si só, como se tranformou no “arroz com feijão” de qualquer desenvolvedor. Indepentendemente de plataforma ou linguagem, todos precisamos consumir esses dados, simplesmente devido ao fato de que a realidade hoje se baseia na conexão entre tudo e todos. Já que essa é uma necessidade tão básica, qual seria a biblioteca que mais abstrai todas as funções necessárias para realizar essa conexão e comunicação no principal dialeto da web (HTTP) e nos trazer todo o tipo de informação nos mais simples passos possíveis, mesmo sem que precisemos entender tudo o que está envolvido nesse processo? Sem dúvida alguma: requests Para instalar essa biblioteca usamos o comando: $ pip install requests Abaixo um simples exemplo do uso da requests: fazer uma chamada à API do Google Maps e imprimir a resposta: import requests params = {&#39;sensor&#39;: &#39;false&#39;, &#39;address&#39;: &#39;Av. Paulista, 1000&#39;} r = requests.get(&#34;http://maps.googleapis.com/maps/api/geocode/json&#34;, params=params) print(r.content)", 
            "tags": "Libraries", 
            "loc": "https://rschalch.github.io/requests.html"
        },
        {
            "title": "Jupyter Notebook", 
            "text":"Sobre a ferramenta Segundo os criadores: O Jupyter Notebook é um aplicativo web que permite criar e compartilhar documentos que contêm live code, equações, visualizações e texto explicativos. Usos incluem: filtragem e transformação de dados, simulação numérica, modelagens estatística, machine learning e muito mais. O que são notebooks? Nos meus primeiros dias com Python comecei usando o terminal rodando o interpretador. Imprimia umas mensagens, concatenava variáveis, construia listas e dicionários, aquelas coisas todas de quem está descobrindo os ifs e elses de uma linguagem. Logo após passei para os editores, escrevendo scripts mais complexos e criando projetos apenas para experimentar a standard library e algumas bibliotecas. Algo de errado com isso? Absolutamente, é o processo pelo qual todo mundo inicia. No entanto, meu aprendizado poderia ter sido muito mais rápido e efetivo se eu tivesse conhecido os notebooks, uma das mais poderosas ferramentas da plataforma Python! Notebooks são arquivos com extensão .ipynb, nos quais podemos armazenar não apenas código, mas também texto, html (via markdown), imagens, etc., que podem nos ajudar a documentar nosso scripts de uma forma bem poderosa. Os notebooks são muito usados na área de ciência e análise de dados pois permitem a medição da performance de um script, armazenagem de resultados, apresentação de gráficos e muitos outros recursos. Além de tudo isso podemos ainda compartilhar esses arquivos, permitindo que outras pessoas rodem todo o conteúdo de um notebook em seu próprio ambiente tendo a facilidade das informações e ilustrações incluídas para o entendimento do código. O estranho é que o próprio site do desenvolvedor até pouco tempo atrás não deixava muito claras as vantagens que essa ferramenta tem para os iniciantes, por isso resolvi escrever esse post. Fala-se muito lá em data science, data analysis, mas infelizmente pecam por não fazerem uma introdução amigável a respeito! Bom, já temos o básico, vamos à prática! Os criadores do Jupyter Notebook recomendam fortemente a instalação do pacote Anaconda, uma distribuição Python que vem com muitas bibliotecas e ferramentas integradas em um único pacote otimizado para desenvolvimento em data science. Vou escrever sobre esse pacote no futuro, mas como é uma distro um pouco pesada para os nossos propósitos, vamos de PIP mesmo ;) Instalando e iniciando o Jupyter Notebook Em primeiro lugar é uma boa idéia fazer o upgrade do gerenciador de pacotes pip, pois o Jupyter tem uma quantidade grande de dependências. $ pip3 install --upgrade pip A instalação é simples: $ pip3 install jupyter E para rodar o Jupyter o comando mais óbvio possível: $ jupyter-notebook Conceitos e funções Quando iniciamos o servidor Jupyter ele nos abre uma página (http://localhost:8888/tree) onde podemos criar novos notebooks baseados nos seguintes kernels: IPython, R e Julia, sendo que apenas o IPython vem com a instalação padrão. Abaixo um preview dessa página já com alguns notebooks criados como exemplo. Esses arquivos encontram-se no mesmo diretório onde inserimos o comando jupyter-notebook dentro do terminal. (Clique nas imagens abaixo para ampliá-las) Clicando no botão “New”, temos a opção de criar uma das seguintes opções: arquivos de texto, pastas, terminais ou um novo notebook baseado no kernel do Python. Vamos criar um novo notebook: Logo ao criar vemos um ambiente parecido com um terminal, com menus, barra de ferramentas, bem intuitivo. Um notebook pode conter uma ou mais células (na figura acima, envolta na cor verde), que são locais onde podemos inserir 3 tipos de conteúdo: código, markdown ou raw input (conteúdo que não será interpretado). Células no formato código (padrão) rodam um prompt com o interpetador IPython, com todas as suas “magic functions” incluídas. Insira o código abaixo na primeira célula e, para rodar e imprimir o resultado, use o comando CTRL + Enter. from IPython.display import YouTubeVideo YouTubeVideo(&#39;7YcW25PHnAA&#39;) Resultado: Apenas por esse exemplo podemos ver o quão útil e poderoso pode ser o Jupyter para todos os tipos de usuários e desenvolvedores, iniciantes ou não. Para saber mais consulte a documentação oficial ou visite a Notebook Gallery", 
            "tags": "Tools", 
            "loc": "https://rschalch.github.io/jupyter-notebook.html"
        },
        {
            "title": "PIP - Gerenciador de Pacotes Python", 
            "text":"“PIP Installs Packages …” … Ou “PIP Installs Python”, é um acrônimo recursivo para o gerenciador de pacotes mais usado na plataforma. Ele usa como fonte principal o PyPI (também conhecido como “Cheese Shop”) o principal respositório de pacotes Python usado pela comunidade. A quantidade de pacotes encontrado no PyPI é imensa, mais de 86 mil pacotes (ou bibliotecas) que podem ser baixados diretamente usando o PIP. Instalar o PIP é muito simples. Primeiro precisamos atualizar o nosso sistema com os updates mais recentes: $ sudo apt update &amp;&amp; sudo apt -y upgrade Para depois instalarmos o gerenciador PIP: $ sudo apt install python-pip Para testarmos se a instalação foi concluída corretamente e checar qual versão: $ pip -V Podemos também pesquisar pacotes nos repositórios: $ pip search nome_do_pacote A instalação de pacotes é muito simples, o seguinte comando baixará não apenas o pacote indicado, mas também suas dependências: $ pip install nome_do_pacote Para listarmos os pacotes atualmente instalados: $ pip list Podemos também criar um arquivo com a referência de todos os pacotes instalados e suas versões. $ pip freeze &gt; requirements.txt O arquivo criado acima permitirá ao PIP instalar novamente esses mesmos pacotes de uma só vez: $ pip install -r requirements.txt A desinstalação de pacotes é feita da seguinte forma: $ pip uninstall nome_do_pacote Para saber mais sobre suas funções: $ pip --help", 
            "tags": "Tools", 
            "loc": "https://rschalch.github.io/python-pip.html"
        },
        {
            "title": "Ambientes Virtuais (virtualenv)", 
            "text":"Conceito e importância dos ambientes virtuais Virtualenvs são ambientes Python isolados dentro do sistema. Muitas distribuições Linux vem com uma instalação Python padrão e atualmente a mais usada é a 2.7. Acontece que nem sempre essa instalação é a mais apropriada para nossos projetos. Ainda mais hoje que vivemos em plena transição para o Python 3. E quando cada um de nossos projetos precisa de uma versão diferente do Python ou de suas bibliotecas? Ainda, e se o ambiente de produção possui uma versão específica? Para qualquer desenvolvedor isso seria uma situação muito complicada, tanto a nível de desenvolvimento, organização ou mesmo em se tratando de depuração de erros e testes. Claro que uma plataforma avançada e robusta como a nossa não deixaria de ter uma solução elegante para esses tipos de problemas. Apresentamos os ambientes virtuais, mais conhecidos como “virtualenvs”. 1. Instalando o pacote virtualenv O Python possui uma biblioteca específica para a criação desses ambientes separados e para instalar esse pacote basta: $ pip install virtualenv 2. Criando o ambiente virtual Agora que o pacote virtualenv foi instalado podemos começar a criar ambientes virtuais. É possível instalar ambientes em qualquer parte do nosso sistema, mas existem duas práticas mais usadas: Instalar no mesmo diretório do projeto ou ter uma pasta específica do sistema para armazená-los. Vamos criar um ambiente virtual com uma instalação para Python 3 dentro do diretório do nosso projeto, em uma pasta chamada “venv” (pode-se dar qualquer nome para ela, mas com a boa prática de evitar maiúsculas, caracteres especiais e espaços) $ cd pasta_do_meu_projeto $ virtualenv -p usr/bin/python3 venv O último comando acima é explicado da seguinte forma: usando o comando virtualenv e a opção -p para especificar qual interpretador python (no caso o Python 3 que está localizado em usr/bin/python3), crie o ambiente virtual chamado “venv” 3. Ativando o ambiente virtual Importante: antes de começar a trabalhar nesse ambiente precisamos ativá-lo com o seguinte comando: $ source venv/bin/activate 4. Instalando bibliotecas dentro do ambiente Temos um ambiente instalado, ativado e pronto para uso! Vamos agora usar o PIP para instalar a biblioteca requests que viverá apenas dentro desse ambiente: $ pip install requests 5. Desativando o ambiente Terminamos de trabalhar no projeto, então podemos desativar o ambiente para que ele nao seja poluído com instalações que não sejam pertinentes a ele: $ deactivate Para excluir o ambiente definitivamente basta deletarmos a pasta venv pois tudo que foi instalado está dentro dela. 6. Dicas Existem tarefas comuns que fazem parte da nossa rotina enquanto trabalhamos com os virtualenvs. Os comandos seguintes exigem que o ambiente virtual esteja funcionando (ativado). Por exemplo, para sabermos quais pacotes estão instalados dentro do ambiente, basta digitarmos: $ pip freeze Outra coisa bastante comum é criar um arquivo chamado requirements.txt, o qual especifica quais são as bibliotecas que estão instaladas no ambiente. Criar esse arquivo é muito fácil: $ pip freeze &gt; requirements.txt Assim, quando outra pessoa do time for replicar o ambiente em sua máquina, tudo que ela precisará fazer é criar esse ambiente e instalar as bibliotecas que ele exige com o seguinte comando: $ pip install -r requirements.txt A opção -r especifica quais são os requerimentos do ambiente, os quais estão listados no arquivo requirements.txt. Esse artigo foi baseado na documentação oficial.", 
            "tags": "Tools", 
            "loc": "https://rschalch.github.io/ambientes-virtuais-virtualenv.html"
        },
        {
            "title": "Como escolher o seu editor", 
            "text":"Simplesmente uma escolha pessoal? Esse assunto nem sempre é tratado com a devida atenção, mas resolvi escrever esse artigo para ajudar os iniciantes (ou talvez aqueles que não estejam satisfeitos o suficiente)a escolherem a sua principal ferramenta de trabalho. Quando estava iniciando em programação, muitas pessoas me diziam: “Deixa isso de lado e parte para o código de uma vez, você tá perdendo tempo com coisas sem importância”. E isso sempre me soou estranho porque eu sabia que teria de passar provavelmente de 70% a 90% de todas as minhas horas de trabalho junto a essa ferramenta. E com o decorrer do tempo comprovei que um bom conjunto de ferramentas aliado a um workflow ágil pode: Reduzir o seu tempo de trabalho; Diminuir o stress com tarefas repetitivas (que ajudam a criar estafa mental); Poupar seu tempo em pesquisas sobre como fazer certas coisas funcionarem direito; Te levar a uma maior satisfação por obter resultados mais rápidos, ajudando inclusive nas suas deadlines. Tendo aprendido Python usando todos os famosos editores do mercado, passando por boas e más experiências, analisando as reais necessidades dos meus projetos, posso dizer que os seguintes requisitos são imprescindíveis para essa escolha: Leveza, Estabilidade e Performance Ferramentas básicas integradas Facilidade de uso Constante manutenção da ferramenta Boa documentação e exemplos de configuração Extenso uso pela comunidade Grande quantidade de plugins Preço Selecionei 4 dos que mais atendem aos quesitos acima e vou resumir seus prós e contras: Pycharm (Jetbrains) Pros O mais completo, excelentes ferramentas integradas Altamente configurável Boa comunidade Possui versão free (Community Edition) Contras Versão completa exige uma subscrição mensal de pagamento Muito pesado Você precisa ter Java instalado na sua máquina para rodá-lo ( What??? ) Sublime Text 3 Pros Levíssimo, inicialização quase que instantânea Extremamente rápido ao responder comandos (construído com Python e extensões C++) Boas opções de configuração Um dos mais adotados pela comunidade Grande quantidade de plugins e temas Contras Não é free (embora possa continuar sendo usado por tempo indeterminado) Ambiente Python: configuração levemente complexa e insatisfatória Lenta manutenção pelo desenvolvedor Atom) Pros Leve Boas opções de configuração Boa quantidade de usuários Suporte a plugins e temas Gratuito e mantido regularmente Contras Possui bugs antigos e adoção de novas funcionalidades é lenta Ambiente Python: muito básico Visual Studio Code Pros Leve Ótimas opções de configuração Crescente quantidade de usuários Suporte a plugins e temas Gratuito e de manutenção bem ativa pela Microsoft O melhor ambiente Python que encontrei até o momento, possui ótimos plugins para a plataforma que funcionam sem precisar de tantos “tweaks” Bem documentado Contras O editor ainda não tem split horizontal, mas já está sendo providenciado pelo desenvolvedor", 
            "tags": "Tools", 
            "loc": "https://rschalch.github.io/escolha-seu-editor.html"
        },
        {
            "title": "Zen do Python", 
            "text":"Sobre a PEP 20 Tim Peters criou essa PEP que é uma coleção de 20 princípios (embora apenas 19 estejam descritos) que influenciam o design da linguagem. Você também pode ter acesso a eles digitando import this em qualquer terminal rodando o interpretador Python. Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&#39;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&#39;s do more of those!", 
            "tags": "References", 
            "loc": "https://rschalch.github.io/zen-python.html"
        },
        {
            "title": "Sobre este blog", 
            "text":"Olá meu nome é Ricardo e sou desenvolvedor web há 13 anos. Se estiver com tempo, paciência e curiosidade o suficiente para querer saber mais, clique aqui! Trabalhei com muitas tecnologias. Não sou nenhum expert, mas posso te ajudar a começar! Meu objetivo aqui é simples: Fazer você ler menos e alcançar mais! Ser uma referẽncia e um guia rápido para todos os que estão começando com Python. Reunir o máximo de matérias para ajudar iniciantes a se sentirem confortáveis com a plataforma e suas ferramentas o mais simples e rapidamente possível. Sendo assim, esse blog não pretende ser um guia completo e definitivo para os tópicos aqui apresentados. Se desejar conhecê-los a fundo consulte suas fontes ou documentações originais. Sempre me deparei com ótimas referências, mas algumas pecavam pelo excesso de informação inútil, falta de clareza e também a falta de cuidado com a percepção de que nem todos os leitores estão familiarizados com tantas tecnologias. Então vou fazer o máximo para que ninguém aqui se sinta perdido nas matérias! Qualquer dúvida ou sugestão por favor me contate e te retornarei o mais rápido possível!", 
            "tags": "main", 
            "loc": "https://rschalch.github.io/pages/sobre-este-blog.html"
        },
        {
            "title": "Contato", 
            "text":"Send var contactform = document.getElementById(&#39;contactform&#39;); contactform.setAttribute(&#39;action&#39;, &#39;//formspree.io/&#39; + &#39;ricardo.schalch&#39; + &#39;@&#39; + &#39;gmail&#39; + &#39;.&#39; + &#39;com&#39;);", 
            "tags": "pages", 
            "loc": "https://rschalch.github.io/pages/contato.html"
        }        
    ]
}